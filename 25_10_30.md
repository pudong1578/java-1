# 윤명근 (202530117)
# 10월 30일 강의

## <a id="final">final</a>, <a id="static">static</a> 사용법 및 특징
``` java
final class FinalClass{
    // 해당 클래스는 자식이 있을 수 없음
}
final class FinalExClass extends RootClass{
    // 해당 클래스는 상속 받으면서 자식이 있을 수 없음
}
class test{ 
    final int NUM = 10; // 상수선언
    static int sInt = 10; // 같은 클래스로 만들어진, 객체 사이에서 변수공유
    static Boolean IsZero() {}; // 해당 함수는 공유되면서, 오버라이드 되면 모두 공유
    final Boolean getMyGen() {}; // 해당 함수는 상속되었을때, 오버라이드 하지못함
    final static Boolean IsNull() {}; // 자식 X, 오버라이드 X, 객체사이 함수 공유
}
```

## Java 클래스 상속
<table border="solid 10px black">
    <tr>
        <th>클래스 생성</th>
        <td><font style="color:orange;"> class </font>[`자신 객체명`] = <font style="color:aqua;">new</font> [`생성자클래스`]();</td>
    </tr>
    <tr>
        <th>클래스 상속</th>
        <td><font style="color:orange;">class</font> [`자신 클래스명`] <font style="color:#00ff00;">extends</font> [`상속 받을 클래스명`] {}</td>
    </tr>
</table>

``` java
class a{
    int member1; int member2;
    void Hello(){}
}
class b extends a{};

public static void main(){
    b object1 = new b();

    b.member1; // 접근 가능
    b.member2; // 접근 가능
    b.Hello(); // 접근 가능
}
```
## Tip. super, this
<table border="solid 10px black">
    <tr>
        <th>super [부모클래스]</th>
        <td><font style="color:#00ff00;">super</font>.member</td>
        <td><font style="color:#00ff00;">super</font>.member()</td>
    </tr>
    <tr>
        <th>this [현재클래스]</th>
        <td><font style="color:orange;">this</font>.member</td>
        <td><font style="color:orange;">this</font>.member()</td>
    </tr>
</table>

``` java
class Point{ // 최상위 root 클래스
    private int x, y; // 멤버 1,2
    public void set(int x, int y){ // 멤버 초기화 함수
        this.x = x;
        this.y = y;
    }
    public void showPoint(String color){ // 멤버 출력 합수
        System.out.printf("(%d, %d)\n", this.x, this.y);
    }
}

class ColorPoint extends Point{ // Point의 showPoint()를 상속받음
    private String color; // 멤버 1
    public void setColor(String color){ // 멤버 초기화 함수
        this.color = color;
    }
    public void printColorPoint(){ // 멤버 출력 함수 + 루트 클래스.showPoint
        System.out.printf("%d ",color);
        showPoint();
    }
}

public static void main(String args[]){
    ColorPoint a = new ColorPoint();
    a.printColorPoint(); // null (null, null);
    a.set(1, 2);
    a.setColor("red");
    a.showPoint(); // (1,2)
    a.printColorPoint(); // red (1,2)
}
```
## `다중상속`은 무엇인가?
다중 상속의 개념만 놓고보면 진짜 단순하다. ( 그냥 부모가 2개 이상이면 다중 상속이다 )

## C++의 다중 상속 [다이아몬드 상속]
``` Cpp
class a{}
class b{}
class c : a, b{} // 가능함
// 하지만 모호성 문제로 인해 [위험, 꼬임]
``` 

## 자바는 허용x [<a id="interface">interface</a> 다중 상속]
``` Java
interface class X{}
interface class Y{}
public interface MyInterface extends  X, Y {
    
}
```
## 자바의 <a id="structer">생성자</a> 호출 순서
<font style="color:orange;">컴파일러</font>에 의해 가장 <font style="color:orange;">최상위 생성자</font>부터 호출이 됨 <br>
그리고 <font style="color:#00ff00;"> 생성 시</font> 전달된 매개변수에 맞게 ``초기화``됨, <br>
<br>
근데 해당 클래스의 생성자는 매개변수가 있었지만 SuperClass는 기본생성자를 호출하게 된다

``` java
class a{
    a(){} // 3 [4 생성]
    a(int a){}
} 
class b{
    b(){}
    b(int a){} // 2 [5 생성]
}
public static String main() { 
    b B = new b(5); // 1 [6 생성]
}
```
## 만약 <font style="color:#7ff;">명시적</font>으로 a의 <font style="color:#f55;">특정 생성자</font>를 생성하고 싶을때라면

``super(a);``을 써주면 된다
``` java
class a{
    a(){} 
    a(int a){} // 3 [4 생성]
} 
class b{
    b(){}
    b(int a){ super(a); } // 2 [5 생성]
}
public static String main() { 
    b B = new b(5); // 1 [6 생성]
}
```

# 정리
<table border="solid 10px black">
    <tr>
        <th></th>
        <th>사용법</th>
        <th>쓰는이유</th>
    </tr>
    <tr>
        <th><a href="#interface">interface</a> (다중상속)</th>
        <td>interface class [클래스명] {}</td>
        <td>두개 이상의 ``부모 클래스``가 필요한 경우</td>
    </tr>
    <tr>
        <th><a href="#extends">extends</a> (상속)</th>
        <td>class [클래스명] extends [부모클래스명] {}</td>
        <td>``부모 클래스``의 맴버나 정보가 필요한 경우</td>
    </tr>
    <tr>
        <th><a href="#final">final</a> (상수)</th>
        <td>생략</td>
        <td>생략</td>
    </tr>
    <tr>
        <th><a herf="#static">static</a> (정적)</th>
        <td>생략</td>
        <td>생략</td>
    </tr>
    <tr>
        <th><a herf="#structer">structer</a> (생성자)</th>
        <td>생략</td>
        <td>생략</td>
    </tr>
    <tr>
        <th><a herf="#this">this</a> (현재 클래스)</th>
        <td>this.member = 3000<br>this.memberM()</td>
        <td>현재 클래스에 있는 생성자나 멤버변수, 멤버메서드에 접근할때 사용한다</td>
    </tr>
    <tr>
        <th><a herf="#super">super</a> (상위 클래스)</th>
        <td>super(1,2,3)</td>
        <td>상위클래스의 생성자나, 맴버변수, 맴버메서드에 접근할때 사용한다</td>
    </tr>
    <tr>
        <th>업케스팅이란?</th>
        <td>Person ob1; <br>Stu ob2 = new Stu();<br>ob1 = ob2; //여기서 업케스팅<br>ob1.name접근가능 <br>ob1.grade접근불가</td>
        <td>슈퍼클래스의 레퍼런스로 서브클래스의 객체를 가리키게 되는 현상</td>
    </tr>
</table>