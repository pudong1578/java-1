# 윤명근 (202530117)
# 10월 31일 강의


<style>
    /*  */
#bar {
  display: none;
  position: absolute;
  background-color: #8a8a8aff;
  width: 4px;
  height: 292px;
  left: 40px;
  top:196px;
}

#mainTable {
  position: relative;
}

body:has(#mainTable:hover) #bar {
  display: block;
}

span.red{color:#ff0088}
span.green{color:#00ff99}
span.blue{color:#0066cc}
span.yellow{color: #ffff99}
span.puple{color: #9966ff}
span.aqua{color: #96ffffff}

table{
    box-shadow: 5px 5px 20px;
}
</style>

## `` 오늘의 키워드 `` - Java

<table id="mainTable" border="solid 1px black">
    <tr>
        <th><a herf="#">업케스팅</a></th>
        <td><ins><span class="green">자식 클래스</span>의 객체가 <span class="green">부모 클래스</span> 타입으로 형변환 되는 것</ins><br>
        <span class="puple">서브 클래스</span>를 <span class="blue">슈퍼 클래스</span>로 옯기는 것</td>
        <td rowspan=2>단점 : 슈퍼클래스 객체인지, 서브클래스 객채인지, 구분하기 어려움<br><del>[instanceof 해결가능]</del></td>
    </tr>
    <tr>
        <th style="white-space: nowrap;"><a herf="#">다운캐스팅</a></th>
        <td><ins>업케스팅 된 것을 다시 원래대로 되돌리는 것</ins><br>
        <span class="blue">슈퍼클래스</span>를 <span class="puple">서브클래스</span>로 옮기는 것</td>
    </tr>
    <tr>
        <th style="white-space: nowrap;"><a herf="#">instanceof</a> [연산자]</th>
        <td><ins>상속 관계에 따라 레퍼런스가 가리키는 객체의 타입을 알아본다</ins><br>
        a instanceof b -> true or false 반환됨</td>
        <td>장점 : 어느 클래스로 만들어진 객체인지 알 수 있음 [다운케스팅에 필요]</td>
    </tr>
    <tr>
        <th style="white-space: nowrap;"><a herf="Overr">메소드 오버라이딩</a> <br>(Method Overriding)</th>
        <td><ins>슈퍼 클래스의 메소드 중복 작성</ins><br>
        @Overrined \n 중복 메소드</td>
        <td><span class="blue">런타임</span>에 바인딩 -> <span class="green">동적바인딩</span> 이라고 불림</td>
    </tr>
    <tr>
        <th style="white-space: nowrap;"><a herf="Overrd">메소드 오버로딩</a> <br>(Method Overload)</th>
        <td><ins>메소드 파라미터 맞춤 작성</ins><br>
        @Overload \n 중복 메소드</td>
        <td><span class="blue">컴파일</span>에 바인딩 -> <span class="green">정적바인딩</span> 이라고 불림</td>
    </tr>
    <tr>
        <th style="white-space: nowrap;"><a herf="#">추상 클래스, 메서드</a> <br>(abstract class, method)</th>
        <td><ins>추상 클래스를 상속받으면 서브 클래스는 추상 클래스가 됨</ins><br>
        추상 클래스의 추상 메서드를 구현한 서브 클래스는 추상 클래스가 아니다
        </td>
        <td><span class="green">추상 클래스</span>는 <span class="puple">new</span> 생성 불가 <br>추상 클래스의 자식클래스는 추상 메서드를 구현하지 않으면 <span class="red">abstract</span>로 선언 해야함<br><ins>용도는, 자식클래스의 다형성, 맞춤형 제작이 가능하기 때문 + 선언만 하여 편안함</ins></td>
    </tr>
    <tr>
        <th style="white-space: nowrap;">인터페이스 <br>(interface class, method)</th>
        <td>final value, static method, abstract 등을 선언하는데 <br>
        abstract를 하나하나 써주는게 귀찮아 만든 interface이다.<br>+ 다중 상속이 가능하여 반드시 필요할때만 사용하는게 좋다</td>
        <td><span class="blue">interface class</span> <span class="aqua">Perent</span> {<br>&nbsp&nbsp&nbsp&nbsp <span class="yellow">PointPrint</span>(); // abstract 생략가능 :><br>&nbsp&nbsp&nbsp&nbsp <span class="blue">static Boolean</span> <span class="yellow">IsNull</span>();<br>}</td>
    </tr>
</table>

<div id="bar"></div>

## 슈퍼클래스로 선언 -> 서브 클래스로 초기화
``` java
Person[] people = new Person[3];
people[0] = new Student("홍길동");
people[1] = new Student("김영희");
people[2] = new Student("이순실");

people[0].Name; // 접근 가능
people[0].StuNumber; // 컴파일 에러
```

## 서브 클래스로 생성 -> 슈퍼 클래스로 타입변환
``` java
Person p = new Student("이재문"); // 업 케스팅
Student s = (Student)p; // 다운 케스팅
s.Name = "이재문"; // 접근가능 : true
s.StuNumber = null; // 접근가능 : true
```

## instanceof 연산자 활용
``` java
class Person {}
class Student extends Person {}
class Researher extends Person {}
class Professor extends Researcher {}

static void print(Person p){ // 슈퍼클래스 Person, 업케스팅으로 받고
    if (p instanceof Person) System.out.print("Person"); // 생성된 클래스 추적
    if (p instanceof Student) System.out.print("Student"); // 생성된 클래스 추적
    if (p instanceof Researher) System.out.print("Researher"); // 생성된 클래스 추적
    if (p instanceof Professor) System.out.print("Professor"); // 생성된 클래스 추적
    System.out.println();
}

public static void main(){
    print(new Person()); // Person
    print(new Student()); // Person Student
    print(new Researher()); // Person Researher
    print(new Professor()); // Person Researcher Professor
}
```
## <span id="Overr">메소드 오버라이딩 (Method Overload) 활용</span>
``` java
class Shape{ void draw() {System.out.println("Shape");} }
// Line이 draw를 오버라이딩 [덮어쓰기]
class Line extends Shape{ void draw() {System.out.println("Line");} }
// Rect draw를 오버라이딩 [덮어쓰기]
class Rect extends Shape{ void draw() {System.out.println("Rect");} }
// Circle draw를 오버라이딩 [덮어쓰기]
class Circle extends Shape{ void draw() {System.out.println("Circle");} }

static void paint(Shape p){ // 업케스팅
    p.draw(); // 오버라이딩 된 함수를 호출
}

public static void main(){
    Line line = new Line();
    paint(line);

    paint(new Shape()); // Shape
    paint(new Line()); // Line
    paint(new Rect()); // Rect
    paint(new Circle()); // Circle
}
```

## <span id="Overrd">메소드 오버로딩의 활용(Method Overload)</span>
``` java
class Shape{
    int width;
    String color;

    Shape(){
        width = 0;
        color = "";
    }
    Shape(int width){
        this.width = width;
        color = "";
    }
    Shape(int width){
        this.width = width;
        color = "";
    }
}
public static void main(){
    Shape[] obArr = new Shape[4];
    obArr[0] = new Shape();
    obArr[1] = new Shape(1);
    obArr[2] = new Shape(1, "red");
}
```

## <span id="Overrd">추상 클래스, 메서드 (abstract class, method) [미완성]</span>
``` java
abstract class Shape{
    
}
public static void main(){
    Shape[] obArr = new Shape[4];
    obArr[0] = new Shape();
    obArr[1] = new Shape(1);
    obArr[2] = new Shape(1, "red");
}
```


## <span id="Overrd">인터페이스 (insterface class) [미완성]</span>
``` java
class Shape{
    
}
public static void main(){
    Shape[] obArr = new Shape[4];
    obArr[0] = new Shape();
    obArr[1] = new Shape(1);
    obArr[2] = new Shape(1, "red");
}
```
